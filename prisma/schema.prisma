generator client {
  provider               = "prisma-client"
  output                 = "../generated/prisma"
  // output                 = "../node_modules/.prisma/client"

  runtime                = "nodejs"
  moduleFormat           = "esm"
  generatedFileExtension = "ts"
  importFileExtension    = "ts"
  
  previewFeatures        = ["fullTextSearchPostgres", "postgresqlExtensions", "queryCompiler", "driverAdapters"]
  seed                   = "node prisma/seed.js"
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pg_trgm]
}

model Community {
  id              String                   @id @unique @default(cuid())
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @default(now()) @updatedAt
  name            String                   @unique @default("") @db.VarChar(50)
  description     String                   @default("This community doesn't have a description.")
  image           String                   @default("/images/favicon/favicon.svg")
  public          Boolean                  @default(true)
  bg_image        String                   @default("/images/default_community_bg.png")
  sidebar_content String                   @default("")
  searchIdx       Unsupported("tsvector")?
  memberships     CommunityMembership[]
  moderators      CommunityModerator[]
  posts           Post[]
  rules           CommunityRule[]
}

model Post {
  id              String                   @id @unique @default(cuid())
  createdAt       DateTime                 @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime                 @default(now()) @updatedAt @db.Timestamptz(3)
  title           String                   @db.VarChar(255)
  content         String
  imageurl        String?
  imagealt        String?
  public          Boolean                  @default(true)
  authorId        String
  communityId     String                   @default("null")
  href            String?
  deletedByAdmin  Boolean?                 @default(false)
  deletedByAuthor Boolean?                 @default(false)
  imageblur       String?
  searchIdx       Unsupported("tsvector")?
  comments        Comment[]
  downvotes       Downvotes[]
  author          User                     @relation(fields: [authorId], references: [id])
  community       Community                @relation(fields: [communityId], references: [id])
  reports         Report[]
  savedBy         SavedPosts[]
  upvotes         Upvotes[]
}

model User {
  id                   String                   @id @unique @default(cuid())
  email                String
  emailVerified        Boolean?                 @default(false)
  emailLastUpdate      DateTime?
  name                 String                   @unique
  username             String                   @unique
  displayUsername      String?
  usernameLastUpdate   DateTime?
  description          String                   @default("This user has not set their description.") @db.VarChar(250)
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt
  image                String?
  password_hash        String?
  github_id            Int?                     @unique
  public               Boolean                  @default(true)
  searchIdx            Unsupported("tsvector")?
  comments             Comment[]
  commentDownvotes     CommentDownvotes[]
  commentUpvotes       CommentUpvotes[]
  memberships          CommunityMembership[]
  moderatedCommunities CommunityModerator[]
  receivedMessages     DirectMessage[]          @relation("Receiver")
  sentMessages         DirectMessage[]          @relation("Sender")
  downvotes            Downvotes[]
  notifications        Notification[]
  posts                Post[]
  reportsSubjectOf     Report[]
  savedPosts           SavedPosts[]
  upvotes              Upvotes[]
  reportsCreated       Report[]                 @relation("Reporter")
  settings             UserSettings[]           @relation("UserToUserSettings")

  sessions             Session[]
  accounts             Account[]
  passkeys             Passkey[]
  apikeys              Apikey[]
  role                 String                   @default("user")
  banned               Boolean                  @default(false)
  banReason            String?                  @default("")
  banExpires           DateTime?

  @@unique([email])
  @@map("user")
}

model Session {
  id              String   @id
  expiresAt       DateTime
  token           String
  createdAt       DateTime
  updatedAt       DateTime
  ipAddress       String?
  userAgent       String?
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  impersonatedBy  String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Passkey {
  id           String    @id
  name         String?
  publicKey    String
  userId       String
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  credentialID String
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?
  createdAt    DateTime?

  @@map("passkey")
}

model Apikey {
  id                  String    @id
  name                String?
  start               String?
  prefix              String?
  key                 String
  userId              String
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  refillInterval      Int?
  refillAmount        Int?
  lastRefillAt        DateTime?
  enabled             Boolean?
  rateLimitEnabled    Boolean?
  rateLimitTimeWindow Int?
  rateLimitMax        Int?
  requestCount        Int?
  remaining           Int?
  lastRequest         DateTime?
  expiresAt           DateTime?
  createdAt           DateTime
  updatedAt           DateTime
  permissions         String?
  metadata            String?

  @@map("apikey")
}

model UserSettings {
  userID                  String          @id
  /// Where the user is redirected when they click a link home (e.g the Command text in the navigation or footer).
  defaultHomeRedirect     String          @default("/")
  /// Whether the user's posts are public. Defaults to true.
  postsPublic             Boolean         @default(true)
  /// Whether the user's account is public. Defaults to true.
  accountPublic           Boolean         @default(true)
  /// Whether the user has 2FA enabled. Defaults to false, doesn't do anything currently.
  twoFactorAuthentication Boolean         @default(false)
  /// What type of 2FA the user has enabled. Defaults to NONE, doesn't do anything currently.
  twoFactorMethod         TwoFactorMethod @default(NONE)
  user                    User[]          @relation("UserToUserSettings")
}

model Upvotes {
  userID    String
  postID    String
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @default(now()) @db.Timestamptz(3)
  Post      Post     @relation(fields: [postID], references: [id])
  User      User     @relation(fields: [userID], references: [id])

  @@id([postID, userID], name: "upvoteID")
}

model Downvotes {
  userID    String
  postID    String
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @default(now()) @db.Timestamptz(3)
  Post      Post     @relation(fields: [postID], references: [id])
  User      User     @relation(fields: [userID], references: [id])

  @@id([postID, userID], name: "downvoteID")
}

model CommentUpvotes {
  userID    String
  commentID String
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @default(now()) @db.Timestamptz(3)
  Comment   Comment  @relation(fields: [commentID], references: [id])
  User      User     @relation(fields: [userID], references: [id])

  @@id([commentID, userID])
}

model CommentDownvotes {
  userID    String
  commentID String
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  updatedAt DateTime @default(now()) @db.Timestamptz(3)
  Comment   Comment  @relation(fields: [commentID], references: [id])
  User      User     @relation(fields: [userID], references: [id])

  @@id([commentID, userID])
}

model CommunityModerator {
  userID      String
  communityID String
  createdAt   DateTime  @default(now()) @db.Timestamptz(3)
  Community   Community @relation(fields: [communityID], references: [id])
  User        User      @relation(fields: [userID], references: [id])

  @@id([userID, communityID])
}

model CommunityMembership {
  userId      String
  communityId String
  createdAt   DateTime  @default(now()) @db.Timestamptz(3)
  updatedAt   DateTime  @default(now()) @db.Timestamptz(3)
  community   Community @relation(fields: [communityId], references: [id])
  user        User      @relation(fields: [userId], references: [id])

  @@id([userId, communityId])
}

model CommunityRule {
  id          String   @id @unique @default(cuid())
  createdAt   DateTime @default(now()) @db.Timestamptz(3)
  updatedAt   DateTime @default(now()) @updatedAt @db.Timestamptz(3)
  communityID String
  title       String
  description String
  community   Community @relation(fields: [communityID], references: [id])
}

model Comment {
  id        String             @id @unique @default(cuid())
  createdAt DateTime           @default(now()) @db.Timestamptz(3)
  updatedAt DateTime           @default(now()) @updatedAt @db.Timestamptz(3)
  userId    String
  postId    String
  replyTo   String?
  content   String
  edited    Boolean            @default(false)
  post      Post               @relation(fields: [postId], references: [id])
  user      User               @relation(fields: [userId], references: [id])
  downvotes CommentDownvotes[]
  upvotes   CommentUpvotes[]
  reports   Report[]
}

model ModerationLog {
  id          String            @id @unique @default(cuid())
  createdAt   DateTime          @default(now()) @db.Timestamptz(3)
  updatedAt   DateTime          @default(now()) @updatedAt @db.Timestamptz(3)
  /// The UserId of the administrator who preformed this action.
  adminId     String            @default("")
  /// The action that was taken. See `ModlogAction` enum.
  action      ModlogAction      @default(UNSPECIFIED)
  /// Whether the action was taken on a user, post or comment (referred to as subject).
  subjectType ModlogSubjectType @default(UNSPECIFIED)
  /// The ID of the subject.
  subjectId   String            @default("")
  /// The communityId of the community where this action was preformed.
  communityId String            @default("")
}

model Report {
  id          String        @id @unique @default(cuid())
  createdAt   DateTime      @default(now()) @db.Timestamptz(3)
  updatedAt   DateTime      @default(now()) @updatedAt @db.Timestamptz(3)
  commentId   String?
  postId      String?
  reason      ReportReason
  information String        @default("")
  subjectType ReportSubject
  userId      String?
  comment     Comment?      @relation(fields: [commentId], references: [id])
  post        Post?         @relation(fields: [postId], references: [id])
  user        User?         @relation(fields: [userId], references: [id])
  reporter    User[]        @relation("Reporter")
}

model Notification {
  /// The CUID of the notification.
  id         String   @id @unique @default(cuid())
  /// When the notification was created.
  createdAt  DateTime @default(now()) @db.Timestamptz(3)
  /// When the notification database entry was last updated.
  updatedAt  DateTime @default(now()) @updatedAt @db.Timestamptz(3)
  /// The title of the notification.
  title      String   @db.VarChar(255)
  /// The main content of the notification.
  content    String
  /// The link of the notification.
  href       String?
  /// The CUID of the receiver.
  receiverId String   @default("null")
  receiver   User     @relation(fields: [receiverId], references: [id])
}

model DirectMessage {
  /// The CUID of the message.
  id         String   @id @unique @default(cuid())
  /// When the message was created.
  createdAt  DateTime @default(now()) @db.Timestamptz(3)
  /// When the message database entry was last updated.
  updatedAt  DateTime @default(now()) @updatedAt @db.Timestamptz(3)
  /// The main content of the message.
  content    String
  /// The CUID of the receiver.
  receiverId String   @default("null")
  /// The CUID of the sender.
  senderId   String   @default("null")
  receiver   User     @relation("Receiver", fields: [receiverId], references: [id])
  sender     User     @relation("Sender", fields: [senderId], references: [id])
}

model SavedPosts {
  postID    String
  userID    String
  createdAt DateTime @default(now()) @db.Timestamptz(3)
  post      Post     @relation(fields: [postID], references: [id])
  user      User     @relation(fields: [userID], references: [id])

  @@unique([postID, userID])
}

enum UserRole {
  ADMIN
  MODERATOR
  USER
}

enum TwoFactorMethod {
  EMAIL_LINK
  EMAIL_CODE
  PHONE
  NONE
}

enum ModlogAction {
  PERM_BAN_USER
  TEMP_BAN_USER
  PIN_POST
  PIN_COMMENT
  DELETE_POST
  DELETE_COMMENT
  ADD_ADMIN
  DELETE_ADMIN
  EDIT_COMMUNITY
  UNSPECIFIED
}

enum ModlogSubjectType {
  USER
  POST
  UNSPECIFIED
  COMMENT
}

enum ReportReason {
  HARASSMENT
  ILLEGAL_CONTENT
  SPAM
  SELF_HARM
}

enum ReportSubject {
  POST
  COMMENT
  USER_PROFILE
}
